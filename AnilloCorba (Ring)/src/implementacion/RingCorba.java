/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package implementacion;

import interfaz.Peer;
import interfaz.PeerHelper;
import interfaz.PeerPOA;
import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.Timer;
import org.omg.CORBA.ORB;
import org.omg.CORBA.ORBPackage.InvalidName;
import org.omg.CosNaming.BindingIteratorHolder;
import org.omg.CosNaming.BindingListHolder;
import org.omg.CosNaming.BindingType;
import org.omg.CosNaming.NameComponent;
import org.omg.CosNaming.NamingContext;
import org.omg.CosNaming.NamingContextExt;
import org.omg.CosNaming.NamingContextExtHelper;
import org.omg.CosNaming.NamingContextHelper;
import org.omg.CosNaming.NamingContextPackage.AlreadyBound;
import org.omg.CosNaming.NamingContextPackage.CannotProceed;
import org.omg.CosNaming.NamingContextPackage.NotFound;
import org.omg.PortableServer.POA;
import org.omg.PortableServer.POAHelper;
import org.omg.PortableServer.POAManagerPackage.AdapterInactive;
import org.omg.PortableServer.POAPackage.ServantNotActive;
import org.omg.PortableServer.POAPackage.WrongPolicy;

/**
 *
 * @author Javier
 */
public class RingCorba extends javax.swing.JFrame {
    
    //Metodo que devuelve un ArrayList con los nombres de los Peers activos en la ejecucion del programa...
    //... obtenidos a traves del servicio de nombres de CORBA.
    public static ArrayList<String> printContext(NamingContext nc, String parent) {
        try {
            final int batchSize = 1000;
            ArrayList<String> referencias = new ArrayList<>();
            BindingListHolder bList = new BindingListHolder( );
            BindingIteratorHolder bIterator = new BindingIteratorHolder( );

            nc.list( batchSize, bList, bIterator );

            for ( int i=0; i < bList.value.length; i++ ) {
                NameComponent[] name = { bList.value[i].binding_name[0] };
                if (bList.value[i].binding_type == BindingType.ncontext) {
                    NamingContext context = NamingContextHelper.narrow(nc.resolve( name ) );
                    //Peer object = PeerHelper.narrow(nc.resolve_str("asd"));
                    printContext( context, parent + name[0].id + "." );
                } else {
                    //System.out.println( parent + name[0].id );
                    referencias.add(name[0].id);
                }
            }
            return referencias;
        } catch (Exception e) {
            System.out.println("ERROR : " + e) ;
            return null;
        }
    }
    /**
     * Creates new form BullyCorba
     */
    
    //Variables globales del programa.
    public static String id="";  //Identificador unico de cada Peer.
    public static NamingContextExt ncRef;  //Servicio de nombres.
    public static ArrayList<String> refer;  //ArrayList - Nombre de los Peers.
    public static boolean coordinador = false;  //Saber si un Peer es coordinador.
    public static String idRecibido = "";  //String que almacena el ID del Peer vecino vacia.
    public static String mensaje = "";  //String que almacena el msj del Peer vecino vacia.
    public RingCorba() {
        initComponents();
        this.setTitle(id);  //Titulo de la ventana del JFrame con el id solicitado.
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jTextField1 = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });

        jPanel1.setBackground(new java.awt.Color(204, 204, 204));

        jTextField1.setEditable(false);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(32, 32, 32)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1)
                    .addComponent(jTextField1, javax.swing.GroupLayout.DEFAULT_SIZE, 207, Short.MAX_VALUE))
                .addContainerGap(36, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 181, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(42, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        
        // -- Cuando cerramos la ventana.
        
        // 1. Revisamos si el que abandona la red es el coordinador para realizar algo antes de eliminar dicha referencia del servicio de nombres.
        // 2. Si no somos el coordinador, simplemente eliminamos dicha referencia del servicio de nombres.
        
        NameComponent pathaux[];
        try {
            if(coordinador){  //Si es el coordinador quien esta abandonando.
                for (int i = 0; i < refer.size(); i++) {  //Recorremos en la lista de Peers activos en la red hasta...
                    if(refer.get(i).equals(id)){  //... encontrar su posicion en el anillo.
                        try {
                            int indexVecino;  //Variable que tendra el ID del Peer antecesor del coordinador.
                            //Este el unico caso donde tenemos que comunicarnos con su antecesor.
                            if(i+1>refer.size()-1){  //Si el antecesor es el primer elemento del ArraList
                                indexVecino = 0;
                            }
                            else{
                                indexVecino = i+1;  //Si el antecesor esta justo despues de nosotros.
                            }
                            Peer object = PeerHelper.narrow(ncRef.resolve_str(refer.get(indexVecino)));  //Obtenemos su referencia...
                            object.sleepPeer();  //... y lo dormimos 2 seg.
                            //Todo esto tiene como fin hacer una pausa entre el Peer vecino del ex coordinador y su antecesor para...
                            //... que el Peer que fue vecino coordinador tenga tiempo de vaciar su bandeja y percatarse que no recibe...
                            //... nada, ya que al dejar de existir el coordinador, crea una conexion directa entre su antecesor y este....
                            //... Recordemos que ningun Peer sabe si el coordinador esta activo o no, debido a que...
                            //... el unico que tenia una conexion directa a él era este vecino coordinador. En este contexto, al hacer...
                            //... hacer esperar 2 seg. a su antecesor habilita al vecino coordinador a darse cuenta de lo ya dicho y...
                            //... finalmente llevar a cabo las elecciones en busca del nuevo coordinador.
                        } catch (NotFound | CannotProceed | org.omg.CosNaming.NamingContextPackage.InvalidName ex) {
                            Logger.getLogger(RingCorba.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                }
            }
            //Independientemente de si el Peer que abandona es el coordinador o no...
            refer = printContext(ncRef, "");  //Recorremos en la lista de Peers activos en la red hasta...
            pathaux = ncRef.to_name(this.id);  //Obtenemos su referencia
            ncRef.unbind(pathaux);  //La eliminamos del servicio de nombres.
        } catch (org.omg.CosNaming.NamingContextPackage.InvalidName | NotFound | CannotProceed ex) {
            
        }
    }//GEN-LAST:event_formWindowClosing

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        // TODO add your handling code here:
        
        //Similar el Bully, todo el algoritmo se concentra aqui...
        //... mientras la ventana del Peer esté activa.
        
        //A diferencia de Bully que cada Peer tiene una conexion directa con todos los otros Peers...
        //... de la red, en este caso solamente conoceremos su vecino desconociendo si hay de mas Peers...
        //... fuera de él.
        
        //El funcionamiento general es basicamente lo mismo que en Bully y la unica excepcion es que no...
        //... se recibe un mensaje de "ok" por parte del Peer que manda la eleccion, por obvias de que al estar...
        //... en anillo unicamente podemos comunicarnos nuestro vecino sig pero él con su anterior no.
        
        // == Cambios con respecto a Bully. ==
        // - El unico Peer que vacia su bandeja es el vecino del coordinador.
        // - El msj que recibe el coordinador es el mismo que transmite a todos los demas Peers en la red a...
        //   excepcion de él y el coordinador mismo.
        // - El proceso que siempre inicia las elecciones es el vecino del coordinador y terminará cuando llegue...
        //   el ID mas grande a su respectivo Peer. (paso de mensajes circular).
        
        // ==NOTAS==
        // - El primer Peer en entrar a la Red sea cual sea su ID sera el coordinador y una vez se retire de la red...
        //   ya se empezará a elegir coordinador en base al ID mas grande. (razones logicas de codigo).
        // - Para la busqueda de los vecinos en el programa, un ArrayList cambia constantemente las posiciones de los ID's...
        //   y no las mantiene fijas como un Array común, por ello que para encontrar el vecino de un Peer en el ArrayList buscamos...
        //   el anterior y viceversa, para encontrar el antecesor buscamos el siguiente. (Esto mantiene funcionando al anillo...
        //   ... en el sentido de las manecillas del reloj).
       
        //Timer del coordinador para enviar su hora cada 0.2 seg.
        Timer accionCoordinador = new Timer(200, new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent e) {
                refer = printContext(ncRef, "");  //Actualiza la lista de los Peers activos en el sistema.
                if(coordinador){  //Garantizamos que solo el coordinador entra a esta seccion.
                    jTextField1.setText("Soy el coordinador");  //Mostramos en su pantalla que es el coordinador.
                    LocalTime hora = LocalTime.now();  //Obtiene la hora.
                    jTextArea1.setText(hora.toString());
                    if(refer.size()>1){  //Enviara msj si hay de 1 Peer en la red.
                        for (int i = 0; i < refer.size(); i++) {  //Recorremos en la lista de Peers activos en la red hasta...
                            if(refer.get(i).equals(id)){  //... encontrar su posicion en el anillo.
                                try {
                                    int indexVecino;  //Variable que tendra el vecino coordinador.
                                    if(i-1>=0){  //Si no es el primer elemento del ArrayList.
                                        indexVecino = i-1;
                                    }
                                    else{
                                        indexVecino = refer.size()-1;  //Si es el primero, su vecino es el ultimo elemento de este Array
                                    }
                                    Peer object = PeerHelper.narrow(ncRef.resolve_str(refer.get(indexVecino)));  //Obtenemos la referencia a dicho vecino.
                                    hora = LocalTime.now();  //Obtiene la hora.
                                    jTextArea1.setText(hora.toString());
                                    String msj= "Coordinador "+id + ": "+ hora;  //Prepara el msj del coordinador.
                                    object.soyElCoordinador(Integer.valueOf(id), msj);  //Se lo mandamos al vecino coordinador.
                                } catch (NotFound | CannotProceed | org.omg.CosNaming.NamingContextPackage.InvalidName ex) {
                                    Logger.getLogger(RingCorba.class.getName()).log(Level.SEVERE, null, ex);
                                }
                            }
                        }
                    }
                    
                }
            }
        });
        
        //Timer para los procesos sirvientes cada seg.
        Timer accionPeer = new Timer(1000, new ActionListener(){
                @Override
                public void actionPerformed(ActionEvent e) {
                    if(!coordinador){  //Garantizamos que solo entran los Peer sirvientes.
                        if(mensaje.equals("")){  //Si el Peer obtiene un msj de vacio.
                            //Como se menciono de manera general, el primer y unico Peer que recibe este msj es el vecino coordinador que...
                            //... en primera ya no es vecino coordinador, puesto que el recibir este msj indica que el coordinador se ha ido.
                            refer = printContext(ncRef, "");  //Actualiza la lista de los Peers activos en el sistema
                            for (int i = 0; i<refer.size() ; i++) {  //Recorremos en la lista de Peers activos en la red hasta...
                                if(refer.get(i).equals(id)){  //... encontrar su posicion en el anillo.
                                    try {
                                        int idVecino;  //Variable que tendra el ID del Peer vecino.
                                        if(i-1>=0){  //Si no es el primer elemento del ArrayList.
                                            idVecino = i-1;
                                        }
                                        else{
                                            idVecino = refer.size()-1;  //Si es el primero, su vecino es el ultimo elemento de este Array.
                                        }
                                        Peer object = PeerHelper.narrow(ncRef.resolve_str(refer.get(idVecino)));  //Obtenemos la referencia del Peer vecino.
                                        object.enviarMensaje(Integer.valueOf(id),"eleccion");  //Le mandamos el msj de hay elecciones junto al ID que lo convoca.
                                    } catch (NotFound | CannotProceed | org.omg.CosNaming.NamingContextPackage.InvalidName ex) {
                                        Logger.getLogger(RingCorba.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                            }
                        }
                        if(mensaje.equals("eleccion")){  //Si el Peer obtiene un msj de "eleccion".
                            try {
                                refer = printContext(ncRef, "");  //Actualiza la lista de los Peers activos en el sistema
                                int idVecino = 0;  //Variable que tendra el ID del Peer vecino.
                                Peer object = null;  //Objeto Peer CORBA sin referenciar.
                                for (int i = 0; i<refer.size() ; i++) {  //Recorremos en la lista de Peers activos en la red hasta...
                                    if(refer.get(i).equals(id)){  //... encontrar su posicion en el anillo.
                                        if(i-1>=0){  //Si no es el primer elemento del ArrayList.
                                            idVecino = i-1;
                                        }
                                        else{
                                            idVecino = refer.size()-1;  //Si es el primero, su vecino es el ultimo elemento de este Array.
                                        }
                                        object = PeerHelper.narrow(ncRef.resolve_str(refer.get(idVecino)));  //Referenciamos a dicho vecino.
                                        break;  //Rompemos el ciclo ya que se encontró el vecino.
                                    }
                                }
                                //Comparamos los ID's del actual y el vecino.
                                if(Integer.parseInt(idRecibido) > Integer.parseInt(id)){ //Si el que recibimos es mayor al nuestro...
                                    object.enviarMensaje(Integer.valueOf(idRecibido), "eleccion");  //...enviamos ese al vecino.
                                }
                                if(Integer.parseInt(idRecibido) < Integer.parseInt(id)){  //Si el que recibimos es menor al nuestro...
                                    object.enviarMensaje(Integer.valueOf(id), "eleccion");  //...enviamos el nuestro al vecino.
                                }
                                if(Integer.parseInt(idRecibido) == Integer.parseInt(id)){  //Si el que recibimos es igual al nuestro...
                                    //...nos indica que a dado la vuelta completa nuestro ID, dandonos a entender que somos el ID...
                                    //...mas alto de toda la red, por tanto seremos el nuevo coordinador.
                                    coordinador = true;  //Activamos que somos coordinador.
                                }
                            } catch (NotFound | CannotProceed | org.omg.CosNaming.NamingContextPackage.InvalidName ex) {
                                Logger.getLogger(RingCorba.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }
                        if(mensaje.equals("coordinador")){  //Si el Peer tiene un msj "coordinador".
                            //System.out.println("coordinador");
                            refer = printContext(ncRef, "");  //Actualiza la lista de los Peers activos en el sistema
                            for (int i = 0; i<refer.size() ; i++) {  //Recorremos en la lista de Peers activos en la red hasta...
                                if(refer.get(i).equals(id)){  //... encontrar su posicion en el anillo.
                                    try {
                                        int idVecino;  //Variable que tendra el ID del Peer vecino.
                                        if(i-1>=0){  //Si no es el primer elemento del ArrayList.
                                            idVecino = i-1;
                                        }
                                        else{
                                            idVecino = refer.size()-1;  //Si es el primero, su vecino es el ultimo elemento de este Array.
                                        }
                                        //En este caso envia a dicho vecino el msj que el coordinador ha enviado, es decir, la hra.
                                        //El siguiente if evita que el msj llegue al propio coordinador.
                                        if(!idRecibido.equals(String.valueOf(refer.get(idVecino)))){
                                            //Obtiene la referencia del Peer vecino.
                                            Peer object = PeerHelper.narrow(ncRef.resolve_str(refer.get(idVecino)));
                                            String msj= jTextField1.getText();  //Obtiene el msj de su pantalla.
                                            object.enviarHora(Integer.valueOf(idRecibido), msj);  //Enviamos dicha informacion.
                                        }
                                    } catch (NotFound | CannotProceed | org.omg.CosNaming.NamingContextPackage.InvalidName ex) {
                                        Logger.getLogger(RingCorba.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                            }
                        }
                        if(mensaje.equals("soyelcoordinador")){ //Este msj solo lo recibe el Peer vecino del coordinador.
                                refer = printContext(ncRef, "");  //Actualiza la lista de los Peers activos en el sistema.
                                for (int i = 0; i<refer.size() ; i++) {  //Recorremos en la lista de Peers activos en la red hasta...
                                    if(refer.get(i).equals(id)){  //... encontrar su posicion en el anillo.
                                        try {
                                            int idVecino;  //Variable que tendra el ID del Peer vecino del vecino coordinador.
                                            if(i-1>=0){  //Si no es el primer elemento del ArrayList.
                                                idVecino = i-1;
                                            }
                                            else{
                                                idVecino = refer.size()-1;  //Si es el primero, su vecino es el ultimo elemento de este Array.
                                            }
                                            //En este punto comienza el ciclo anillo de todos los Peers ya que enviará a su vecino la hora...
                                            //... dada por el coordinador asi como su ID, en otras palabras, se trasmite el msj del...
                                            //... coordinador a todos en la red.
                                            //Este if evita enviar el mensaje del coodinador al propio coordinador
                                            if(!idRecibido.equals(String.valueOf(refer.get(idVecino)))){
                                                //Obtiene la referencia del Peer vecino del vecino coordinador.
                                                Peer object = PeerHelper.narrow(ncRef.resolve_str(refer.get(idVecino)));
                                                String msj= jTextField1.getText(); //El msj a transmitir es el mismo que envio el coordinador.
                                                object.enviarHora(Integer.valueOf(idRecibido), msj);  //Envia esta informacion al vecino.
                                            }
                                        } catch (NotFound | CannotProceed | org.omg.CosNaming.NamingContextPackage.InvalidName ex) {
                                            Logger.getLogger(RingCorba.class.getName()).log(Level.SEVERE, null, ex);
                                        }
                                    }
                                }
                                mensaje = "";  //Al final vaciamos su bandeja igual que en Bully por si en el prox. seg. continua vacia...
                                               //... detectamos que el coordinador se fue.
                            }
                    }   
                }
            });
        accionCoordinador.start();
        accionPeer.start();
    }//GEN-LAST:event_formWindowOpened

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(RingCorba.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(RingCorba.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(RingCorba.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(RingCorba.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        
        try{
            
            // Crea e inicializa el ORB de CORBA
            ORB orb = ORB.init(args, null);
            // Referencia al POA raiz y activa el manejador de POA
            POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
            rootpoa.the_POAManager().activate();
            
            PeerImpl peer = new PeerImpl();
            // Obtiene la referencia al objeto del servidor
            
            org.omg.CORBA.Object ref = rootpoa.servant_to_reference(peer);
            Peer href = PeerHelper.narrow(ref);
            
            // Obtiene el naming context de la raiz
            org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService");
            // Usa el NamingContextExt en lugar de NamingContext. 
            // Esto es parte de Interoperable naming Service.  
            ncRef = NamingContextExtHelper.narrow(objRef);

            //Pedimos el ID al usuario, es importante que en este caso sea...
            //... un numero, ya que elegimos al proceso coordinador en base al...
            //... ID mas grande.
            id = JOptionPane.showInputDialog("Introduce tu ID");
            RingCorba.id = id;  //Asignamos dicho ID al titulo del JFrame.
            //Guardamos la referencia a este objeto en el servicio de nombres.
            NameComponent path[] = ncRef.to_name( id );
            ncRef.bind(path, href);
            
            //Actualizamos el ArrayList que contiene los nombres de los Peers.
            refer = printContext(ncRef, "");
            
            //En caso de que no se cierre un Peer como debe ser (desde la ventana), pj. por consola ...
            //... Descomentar el for justo debajo, correr el programa y volver a comentarlo. Su funcion es...
            //... limpiar completamente nuestro servicio de nombres con el fin de borrar la referencia de...
            //... objeto de dicho Peer que ya no existe.
            
            /*
            for (int i = 0; i<refer.size() ; i++) {
                NameComponent pathaux[] = ncRef.to_name(refer.get(i));
                ncRef.unbind(pathaux);
            }
            */
            
            //Muestra en consola la lista Peers activos en el sistema.
            for (int i = 0; i < refer.size(); i++) {
                System.out.println(refer.get(i));
            }
            
            //Activa la interfaz grafica.
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    new RingCorba().setVisible(true);
                }
            });
            //Inicializamos el objeto CORBA.
            orb.run();
        }catch(InvalidName | AdapterInactive | ServantNotActive | WrongPolicy | HeadlessException | org.omg.CosNaming.NamingContextPackage.InvalidName | NotFound | CannotProceed | AlreadyBound e){
            
        }
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private static javax.swing.JTextArea jTextArea1;
    public static javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
    static class PeerImpl extends PeerPOA {

        private ORB orb;

        @Override
        public void enviarHora(int id, String msj) {  //Metodo para enviar la hora a cada uno de los Peers de la red.
            //System.out.println("Mensaje :"+msj);
            idRecibido = String.valueOf(id);  //Guarda el ID del coordinador.
            mensaje = "coordinador";  //El Peer que recibe este msj, indica que hay coordinador activo.
            jTextField1.setText(msj);  //Muestra el msj en pantalla.
            String temp = jTextArea1.getText();
            temp += "\n"+msj;
            jTextArea1.setText(temp);
        }
        @Override
        public void enviarMensaje(int id, String msj) {  //Metodo para las elecciones.
            //System.out.println("Mensaje :"+msj);
            idRecibido = String.valueOf(id);  //Va guardando ID mas grande mientras itera entre los Peers.
            mensaje = msj;  //El peer recibe la palabra "eleccion".
        }
        
        @Override
        public void soyElCoordinador(int id, String msj) {  //Este metodo solo es para el vecino del coordinador.
            //System.out.println("Mensaje :"+msj);
            idRecibido = String.valueOf(id);  //Guarda el ID del coordinador.
            mensaje = "soyelcoordinador";  //El Peer que recibe este msj, indica que es el vecino coordinador.
            jTextField1.setText(msj);  //Muestra en su pantalla la hra. del coordinador.
            String temp = jTextArea1.getText();
            temp += "\n"+msj;
            jTextArea1.setText(temp);
        }
        @Override
        public void sleepPeer() {  //Metodo solo para el antecesor del coordinador.
            try {
                Thread.sleep(2000);  //Lo dormimos 2 seg.
                mensaje="";  //Vaciamos su bandeja.
            } catch (InterruptedException ex) {
                Logger.getLogger(RingCorba.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}